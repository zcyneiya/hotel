# 易宿酒店预订平台 - 项目文档

## 1. 项目概述

### 1.1 项目简介
易宿酒店预订平台是一个面向现代旅游出行场景的综合服务系统，旨在连接酒店商家与消费者，提供高效、直观的信息交互服务。本项目不仅仅是一个简单的酒店展示目录，而是一个深度集成了地理位置服务、拥有商家入驻审核机制、并提供极致移动端交互体验的完整业务系统。项目整体包含三大核心端：面向消费者的移动端、面向商家与平台管理员的 PC 管理端，以及提供稳定数据支撑与业务逻辑处理的后端服务。

### 1.2 UI/UX 设计规范
- **移动端**：采用极简主义设计风格，大面积留白，突出酒店高质量图片。交互上大量引入动画，例如底部详情抽屉的拖拽、图片的缩放过渡，力求达到媲美原生 iOS/Android 的丝滑体验。
- **管理端**：遵循 Ant Design 的企业级中后台设计规范，强调信息密度的合理分配和操作路径的最短化。表单录入采用分步式或抽屉式设计，减少用户的认知负担。

---

## 2. 系统架构

### 2.1 整体系统架构设计
本项目采用经典的前后端分离架构，整体分为四层：

#### 2.1.1 表现层 (Presentation Layer)
- **移动端**：基于 React Native 构建，负责面向 C 端用户的交互展示、设备硬件调用（如定位）以及复杂动画渲染。
- **管理端**：基于 React 18 构建的单页应用，负责面向 B 端商家和平台管理员的复杂表单处理、数据表格展示和后台管理。

#### 2.1.2 业务逻辑层 (Business Logic Layer)
- **Node.js API 服务**：作为整个系统的中枢，处理所有的业务逻辑，包括用户认证、权限校验、酒店状态机流转、文件上传处理等。
- **第三方服务集成**：在这一层对接高德地图 Web 服务 API（用于后端的地理编码和 POI 检索）。

#### 2.1.3 数据访问层 (Data Access Layer)
- **Mongoose ORM**：作为 Node.js 与 MongoDB 之间的桥梁，负责数据模型的定义、数据校验、中间件钩子（Hooks）以及复杂的聚合查询（Aggregation）。

#### 2.1.4 基础设施层 (Infrastructure Layer)
- **MongoDB 数据库**：存储所有结构化与半结构化数据。
- **静态资源存储**：本地文件系统用于存储用户上传的酒店图片。

### 2.2 数据库架构与核心模型设计 (MongoDB)
选择 MongoDB 作为底层数据库。

#### 2.2.1 User 模型设计
用于统一管理平台的所有账号体系。
- `username`, `password` (bcrypt 加密存储)
- `role`: 枚举类型 `['merchant', 'admin']`，用于实现 RBAC（基于角色的访问控制）。
- `email`, `phone`: 联系方式。

#### 2.2.2 Hotel 模型设计
系统的核心业务模型，结构最为复杂。
- **基础信息**：`name` (中英文), `address`, `city`, `starLevel`, `facilities`, `images`。
- **房型信息 (嵌套 Schema)**：`rooms` 数组，包含 `type`, `price`, `totalRooms`, `availableRooms`, `capacity` 等。
- **地理位置**：`location` 包含 `lng` 和 `lat`，并建立了 `2dsphere` 空间索引，支持基于距离的地理位置查询。
- **周边数据**：`nearby` 嵌套对象，包含 `attractions`, `transportation`, `shopping` 数组，用于缓存周边 POI 数据，做信息兜底，减少对第三方 API 的频繁调用。
- **状态机**：`status` 枚举 `['draft', 'pending', 'published', 'rejected', 'offline']`。

#### 2.2.3 Audit 模型设计
用于实现系统的可追溯性。
- `hotelId`: 关联的酒店 ID。
- `operatorId`: 执行操作的用户 ID。
- `action`: 动作枚举 `['submit', 'approve', 'reject', 'offline', 'restore']`。
- `previousStatus`, `newStatus`: 状态变更前后的快照。
- `reason`: 驳回或下线的具体原因。

---

## 3. 详细技术栈与选型深度解析

### 3.1 移动端技术选型：React Native + Expo
#### 3.1.1 React Native

在移动端技术选型时，我们选择 React Native 。RN 拥有极其丰富的第三方库，特别是对于地图、动画、手势等复杂场景，社区都有成熟的解决方案。

#### 3.1.2 Expo
传统的 RN CLI 项目在环境配置上往往会耗费大量时间，且容易遇到各种编译错误。我们引入了 Expo 框架：
- **开箱即用**：无需配置复杂的原生环境，通过 `npx expo start` 即可在真机上通过 Expo Go App 实时预览。
- **EAS Build**：利用 Expo Application Services，可以在云端完成 iOS 和 Android 的打包构建，彻底摆脱了对本地 Mac 硬件的依赖。

### 3.2 管理端技术选型：React 18 + Vite + Ant Design
#### 3.2.1 Vite 构建工具的优势
摒弃了传统的 Webpack，选择 Vite。Vite 基于 ES Modules 的冷启动机制，使得本地开发服务器的启动时间从十几秒缩短到了毫秒级。

#### 3.2.2 Ant Design 的企业级组件实践
管理后台涉及大量的表单录入和数据表格展示。Ant Design 提供了极其强大的组件支持：
- **动态表单**：在“新增酒店”页面，房型信息的录入采用了 `Form.List` 组件，支持动态增删房型，极大地简化了复杂嵌套数据的状态管理。
- **数据表格**：在“酒店审核”页面，利用 `Table` 组件的自定义渲染和过滤功能，直观展示酒店状态（草稿、待审核、已发布等），并结合 `Tag` 组件进行颜色区分。

#### 3.2.3 Zustand 状态管理
相比于 Redux 的繁琐模板代码，我们选择了 Zustand 作为管理端的全局状态管理库。它极其轻量，API 设计简洁，非常适合用于管理用户的登录状态、权限角色以及全局的 UI 配置。

### 3.3 后端技术选型：Node.js + Express + MongoDB
#### 3.3.1 Node.js 异步非阻塞的优势
酒店预订平台是一个典型的 I/O 密集型应用（大量的数据库查询、第三方地图 API 调用、图片文件读写）。Node.js 基于事件驱动和非阻塞 I/O 的特性，使其在处理高并发请求时表现出色，且前后端统一使用 JavaScript/TypeScript，降低了沟通成本。

#### 3.3.2 Express 框架的灵活性
选择 Express 因为 Express 更加轻量和灵活。我们通过自定义中间件实现了优雅的请求拦截：
- `auth.js`：解析 JWT Token，将用户信息挂载到 `req.user`。
- `errorHandler.js`：统一捕获全局异常，返回标准化的 JSON 错误响应。

#### 3.3.3 MongoDB 文档型数据库的契合度
酒店数据结构复杂（包含多语言名称、动态房型数组、嵌套的周边 POI 列表）。如果使用 MySQL，可能需要设计 5-6 张表并进行复杂的 JOIN 操作。而 MongoDB 的 BSON 文档结构完美契合了这种数据模型，一次查询即可获取完整的酒店聚合信息，大幅提升了读取性能。

---

## 4. 核心功能模块

### 4.1 移动端：LBS 地图与 POI 深度集成
这是本项目最具挑战性也是最具亮点的功能模块。

#### 4.1.1 WebView 桥接高德地图 JS API 的实现原理
React Native 社区虽然有 `react-native-amap3d` 等原生封装库，但在处理复杂的自定义交互（如动态加载海量 POI、自定义气泡样式）时，往往存在兼容性问题或 API 滞后。
我们采用了 **WebView 注入高德地图 JS API** 的方案：
1. 在 `MapScreen.tsx` 中，渲染一个全屏的 `WebView` 组件。
2. 将高德地图的 HTML/JS 代码作为字符串通过 `source={{ html: ... }}` 注入到 WebView 中。
3. **双向通信**：
   - **RN -> WebView**：通过 `postMessage` 传递 `render / focus`等指令，控制 marker 绘制、高亮与聚焦。
   - **WebView -> RN**：在地图内部监听标记点的点击事件，通过 `window.ReactNativeWebView.postMessage()` 将 POI index 发送回 RN，触发列表滚动与高亮。

#### 4.1.2 周边 POI 数据的动态获取与渲染
在 `DetailScreen` 中，当用户点击“查看周边”时，系统会执行以下逻辑：
1. 调用后端封装的 `poiService.geocode`，将酒店的文本地址转换为精确的经纬度坐标。
2. 并发调用三个 `poiService.around` 请求，分别传入不同的 POI 分类编码（如 `110000` 代表风景名胜，`150000` 代表交通设施，`060000` 代表购物中心）。
3. 将获取到的 POI 数据进行清洗和归一化（`normalizePoiList`），提取出名称、距离、类型等关键字段，并截取前 n 条展示，保证渲染性能。

### 4.2 管理端：动态表单与地图选址
#### 4.2.1 复杂酒店信息的表单状态管理
在 `HotelForm.jsx` 中，商家需要录入大量信息。我们利用 Ant Design 的 `Form` 组件实现了数据的双向绑定和严格的校验规则。特别是对于图片上传，我们集成了 `browser-image-compression` 库。在用户选择图片后，前端会先在浏览器内存中对图片进行压缩（限制最大宽度和文件大小），然后再通过 `FormData` 上传到服务器，极大地节省了服务器带宽和存储成本。

#### 4.2.2 逆地理编码与坐标拾取
为了确保商家录入的酒店位置绝对准确，我们在表单中嵌入了高德地图选址组件：
1. 商家输入文本地址，点击“搜索”，调用高德 `Geocoder` 插件进行地理编码，地图自动平移到对应位置并放置大头针。
2. 商户点击地图或拖拽标记后，，触发逆地理编码（Reverse Geocoding），获取完整地址字符串并回填到“详细地址”。
3. 经纬度同步写入 `location` 字段，提交后持久化到数据库。

### 4.3 后端：RBAC 权限控制与状态机流转
#### 4.3.1 基于 JWT 的无状态认证
系统采用 JSON Web Token (JWT) 进行身份验证。用户登录成功后，服务器签发包含 `userId` 和 `role` 的 Token。后续的所有受保护请求都必须在 HTTP Header 中携带 `Authorization: Bearer <token>`。后端的 `auth.js` 中间件会校验 Token 的合法性，并拦截越权访问。

#### 4.3.2 酒店状态机与审核日志
酒店的生命周期被严格定义为一个状态机：
- `draft`：商家保存的草稿，仅自己可见。
- `pending`：商家提交审核，平台管理员可见。
- `published`：审核通过，移动端 C 端用户可见。
- `rejected`：审核驳回，商家需修改后重新提交。
- `offline`：违规下线，强制从 C 端隐藏。

每次状态变更，后端的 Controller 不仅会更新 `Hotel` 集合的 `status` 字段，还会强制在 `Audit` 集合中插入一条记录。这种设计保证了业务数据的完整性和可追溯性，为后续的平台运营和纠纷处理提供了数据支撑。

---

## 5. 难点突破

### 5.1 跨平台地图组件的深度定制与性能优化
**难点**：在 React Native 中集成国内的地图服务（高德/百度）一直是个痛点。原生 SDK 接入复杂，且容易引发各种 Crash；而简单的 WebView 嵌入又无法实现与 RN 原生组件的深度交互。

**突破**：我们设计了一套“WebView + PostMessage 通信桥”的成熟方案。为了解决 WebView 加载地图时的白屏闪烁问题，我们在 HTML 模板中预置了骨架屏，并在地图 `complete` 事件触发后再隐藏骨架屏。同时加入了 Reanimated 驱动的抽屉交互，以及信息列表与地图标记的联动。

### 5.2 复杂状态的动画交互与 JS 线程阻塞问题
**难点**：在实现地图底部的可拖拽抽屉时，如果使用 RN 自带的 `Animated` API 和 `PanResponder`。当抽屉内包含大量 POI 列表数据时，拖拽手势会引发频繁的 React 组件 Re-render，导致 JS 线程严重阻塞，拖拽过程出现明显的卡顿和延迟。

**突破**：全面重构动画层，引入 `react-native-reanimated`。将手势的监听和视图的位移计算全部下放到 UI 线程。即使 JS 线程正在进行繁重的网络请求或数据解析，抽屉的拖拽动画依然能保持丝滑体验。

### 5.3 大图上传与图片存储优化
**难点**：现代手机拍摄的酒店照片动辄 5MB-10MB，如果直接上传，不仅会导致请求超时，还会迅速耗尽服务器的存储空间，并在移动端加载时造成严重的网络延迟。

**突破**：在管理端引入 `browser-image-compression`，在文件上传前进行纯前端的压缩处理，将 10MB 的原图无损压缩至 500KB 左右。在后端，使用 `multer` 中间件接收文件，并按日期生成唯一的 UUID 文件名，防止文件覆盖。图片统一存储在本地静态资源目录，前端通过URL访问，支持CDN加速和缓存，提升移动端加载速度和稳定性。


### 5.4 长列表渲染优化
**难点**：移动端长列表场景下，酒店数据量大，容易导致页面卡顿、内存溢出、加载慢、交互不流畅。

**突破**：使用FlatList组件替代ScrollView，支持虚拟化渲染，仅渲染屏幕可见部分，并结合initialNumToRender、maxToRenderPerBatch、windowSize等参数，优化首屏和批量渲染。实现分页加载，用户滑到底部时自动请求下一页数据，避免一次性加载全部数据。hasMore标记是否还有更多数据，防止重复请求。加载时显示骨架屏，且底部加载动画提示数据加载中，避免白屏。

---

## 6. 成员分工与敏捷协作模式

### 6.1 团队角色定义
本项目采用敏捷开发模式，团队成员职责明确，紧密协作：
- **张楚依**：完成前期项目框架搭建，后端服务开发，并实现移动端基础功能呈现。
- **谭昕霖**：重点完成高德地图模块的深度集成，并进行移动端和PC端逻辑优化。
- **许诺**：完成后台系统的开发，完善态表单设计、状态管理等。

### 6.2 Git 工作流与代码规范
为了保证代码质量和协作效率，我们对开发流程进行规范（`doc/collaboration-guide.md`）：
- **分支管理**：采用 Feature Branch 工作流。主分支 `master` 保持绝对稳定，所有新功能必须在 `feature/xxx` 分支上开发，测试无误后通过 Pull Request 合并。
- **提交规范**：严格遵循 Conventional Commits 规范（如 `feat:`, `fix:`, `docs:`, `refactor:`），确保 Git 历史清晰可读。
- **代码格式化**：全栈统一配置 Prettier 和 ESLint，在提交前通过 Git Hooks 自动进行代码格式化和静态语法检查。

### 6.3 接口契约与前后端联调机制
在开发初期，前后端共同制定了详细的 RESTful API 接口文档（基于 Swagger 规范）。前端在后端接口未完成前，基于接口契约使用 Mock 数据进行页面开发；后端完成后，前端只需切换环境变量中的 `API_BASE_URL` 即可无缝对接，极大地提升了并行开发的效率。
